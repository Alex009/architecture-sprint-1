# Практическое задание по разделению на микрофронтенды

## Задание №1

### Декомпозиция монолитного микрофронтенда

В проекте можно выделить 3 функциональных группы, которые могут быть распределены по разным командам:
1. авторизация и регистрация
2. пользователи (профиль, карточка пользователя)
3. карточки (конкретно в текущий момент времени для пользователя это выглядит как "места", но со стороны реализации имеется более общее название - карточки и может использоваться в разных контекстах)

Вход пользователей и профиль можно и объединить, но с развитием проекта вполне возможно что авторизация и регистрация может усложняться, а её выделение из микрофронтенда пользователей выглядит достаточно простым, а также позволит снизить сложность микрофронтенда пользователей, где с развитием точно будет увеличиваться объем функционала и сложность.

### Выбор технологии микрофронтендов

Выбирая между Single SPA и Webpack Module Federation в данном проекте выбран WMF, потому что:
1. разные микрофронтенды будут на общей технологии (React). Главное преимущество Single SPA в возможности использовать разные технологии для разных микрофронтов.
2. выбор микрофронтенда будет идти не по URL, а допускать встраивание разных микрофронтендов друг в друга (например в списке карточек в хидере показывать карточку текущего пользователя). Single SPA предполагает что в зависимости от url будет разных микрофронтенд использоваться.
3. так как микрофронтенды будут на общей технологии, то WMF позволит переиспользовать общие зависимости, сократив трафик и время загрузки
4. Webpack Module Federation имеет тесную интеграцию с React, значит проверен на используемом в проекте стеке.

### Запуск проекта для проверки
```bash
docker compose up
```

### Комментарии к решению

Микрофронтенды поставляют для хост приложения компоненты с логикой, но в самих микрофронтндах не подготовлено приложение для проверки и разработки компонентов (кроме микрофронтенда авторизации), поэтому при попытке зайти напрямую на микрофронтенд пользователей или карточек - будет пустой экран. В реальных условиях предполагается что команды будут поддерживать свои стартовые страницы как приложения для отладки всего функционала.

Хост приложение (основной проект `frontend`) сохранило в себе лейаут приложения - оно отвечает за отображение хидера и футера, а вот контент страницы идет уже с микрофронтов.

## Задание №2

Обновленная архитектурная схема доступна в draw.io файле [arch-microservices.drawio](arch-microservices.drawio) на листе Microservices.

Монолитное приложение было разбито на несколько микросервисов:
1. Пользователи - авторизация и работа с профилями пользователей.
2. Товары - работа с товарами, которые создаются пользователями
3. Услуги - работа с услугами, которые создаются пользователями. Можно было сделать единый сервис "Товары и Услуги", но бизнес-логика услуг и товаров скорее всего отличается, либо начнет сильнее отличаться со временем, и команда занимающаяся этим сервисом в итоге разделится на подкоманды "товары" и "услуги"
4. Аукционы - сервис аукционов, которые создаются и проводятся пользователями, а администраторы их модерируют.
5. Заказы - создание, исполнение и управление заказами, которые создаются после завершения аукциона.
6. Платежи - весь процесс проведения оплаты по заказу.
7. Поддержка - работа с заявками пользователей на тему аппеляций или техподдержки. Помимо пользователей с данным сервисом работают и сотрудники техподдержки.
8. Отчеты - сервис генерации отчетов.

Для взаимодействия между микросервисами используется событийно-ориентированный подход. Для распространения событий добавлен Apache Kafka, через который сервисы взаимодействуют между собой.
События строить будем в соответствии с паттерном Saga. То есть, если мы создаем оплату при переходе заказа в статус оплаты, то заказ имеет компенсирующее действие, на случай ошибки создания или проведения оплаты - заказ будет отменен.

В некоторых случаях, когда микросервису нужно прочитать данные другого микросервиса, используется прямое обращение к другому сервису. Например, сервис отчетов будет напрямую обращаться к сервисам товаров, услуг, заказов и прочим, для получения необходимых для построения отчетов данных.


# Заметки на будущее
1. Для работы WMF важно чтобы стартовый файл не содержал сам какой-то логики, а был просто загрузчиком, в котором есть только `import("./bootstrap.js")`, иначе можно постоянно ловить ошибки связанные с eager initialization от shared зависимостей
2. Важно расшарить зависимости react, react-dom, иначе микрофронтенды начнут друг другу ломать работу
3. При работе с react-scripts нельзя изменить порт дев сервера. Надо передавать переменную окружения PORT
4. Если нужно чтобы какой-то класс подгрузился с другого микрофронтенда "блокирующе" - используем `import { CurrentUserContext } from 'AuthApp/CurrentUserContext';` в начале файла. А если хотим подгрузить лениво какой-то ui компонент - `const Register = React.lazy(() => import('AuthApp/Register'));`
5. При пересечении имен css файлов будет загружен только один из них (если например в компонентах auth подключать ../index.css то подключится только от одного из микрофронтов). UPD - такая проблема возникнет если в package.json у разных микрофронтов будет одно и тоже имя. А также может быть забыт импорт какого-либо css внутри самого index.css

# Полезные команды
```bash
nvm use 18.20.4
```
